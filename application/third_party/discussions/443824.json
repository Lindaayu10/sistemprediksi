[
  {
    "Id": "1044170",
    "ThreadId": "443824",
    "Html": "I am trying to read a Excel file with formula's in most of my columns. Then I receive this error.\r<br />\n<br />\nPHP Fatal error:  Uncaught exception 'PHPExcel_Exception' with message 'ISM-XE1203FI63TRX91!AI7 -&gt; ISM-XE1203FI63TRX91!AO9 -&gt; ISM-XE1203FI63TRX91!AN9 -&gt; ISM-XE1203FI63TRX91!AM9 -&gt; ISM-XE1203FI63TRX91!AP9 -&gt; ISM-XE1203FI63TRX91!AN9 -&gt; Cyclic Reference in Formula' in /abc//Classes/PHPExcel/Cell.php:307\\nStack trace:\\n#0 /abc/reader.php(226): PHPExcel_Cell-&gt;getCalculatedValue()\\n#1 /abc//reader.php(132): calculateFormula(Object(PHPExcel_Worksheet), 'AI7')\\n#2 /abc/reader.php(36): readTemplateData('tmp/Template...')\\n#3 {main}\\n  thrown in /abc/Classes/PHPExcel/Cell.php on line 307\r<br />\n<br />\nAny idea how to resolve this ?.<br />\n",
    "PostedDate": "2013-05-15T17:44:59.773-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1044288",
    "ThreadId": "443824",
    "Html": "If your formulae contain cyclic references, then you need to choose how to deal with them, as you do in MS Excel itself. The default behaviour is to throw an Exception like this, which is similar to the way MS Excel will behave by default.\r<br />\nThe alternative is to tell PHPExcel to follow the cycle for a fixed number of iterations by setting the calculation engine to:<br />\n<div style=\"color:Black;background-color:White;\"><pre>\r\nPHPExcel_Calculation::getInstance()-&gt;cyclicFormulaCount = 1;\r\n</pre></div>or to any value &gt; =1 indicating the number of iterations to cycle<br />\n",
    "PostedDate": "2013-05-15T23:46:02.51-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1078299",
    "ThreadId": "443824",
    "Html": "Fatal error: Uncaught exception 'PHPExcel_Calculation_Exception' with message 'Summary!B12 -&gt; FinancialDataValues!M8 -&gt; FinancialData!V7 -&gt; ForecastsData!C7 -&gt; FinancialDataValues!M8 -&gt; Cyclic Reference in Formula' in E:\\xampp-portable\\htdocs\\ValueCalculator\\libs\\php\\PHPExcel\\Cell.php:298 Stack trace: #0 E:\\xampp-portable\\htdocs\\ValueCalculator\\libs\\php\\PHPExcel\\Writer\\Excel2007\\Worksheet.php(1078): PHPExcel_Cell-&gt;getCalculatedValue() #1 E:\\xampp-portable\\htdocs\\ValueCalculator\\libs\\php\\PHPExcel\\Writer\\Excel2007\\Worksheet.php(1025): PHPExcel_Writer_Excel2007_Worksheet-&gt;_writeCell(Object(PHPExcel_Shared_XMLWriter), Object(PHPExcel_Worksheet), 'B12', Array, Array) #2 E:\\xampp-portable\\htdocs\\ValueCalculator\\libs\\php\\PHPExcel\\Writer\\Excel2007\\Worksheet.php(83): PHPExcel_Writer_Excel2007_Worksheet-&gt;_writeSheetData(Object(PHPExcel_Shared_XMLWriter), Object(PHPExcel_Worksheet), Array) #3 E:\\xampp-portable\\htdocs\\ValueCalculator\\libs\\php\\PHPExcel\\Writer\\Excel2007.php(262): PHPExcel_Writer_Excel2007_Worksheet-&gt;writeWorksheet(Obje in E:\\xampp-portable\\htdocs\\ValueCalculator\\libs\\php\\PHPExcel\\Cell.php on line 298\r<br />\n<br />\nthe problem is that my summary!b12: =INDEX(FinancialDataValues!A8:AS8,B10+Variables!A5)\r<br />\nwhere B10 is -2001\r<br />\nVariable!A5 is 2010\r<br />\nSo that should return me the index from financialdatavalues from column 9 if i'm not wrong....when it try to calculate each value until it gets to position 9.\r<br />\n<br />\n financialdatavalues!A8:I8 {'',\t&quot;Sales&quot;,\t=FinancialData!C7,\t=FinancialData!E7\t,=FinancialData!G7,\t=FinancialData!I7,\t=FinancialData!K7,\t=FinancialData!M7,\t=FinancialData!O7}\r<br />\nwhere my financialdata!o7 is empty... why it return me cyclic reference?\r<br />\n<br />\nthere isn't any way to bypass it?\r<br />\n<br />\nthank you!<br />\n",
    "PostedDate": "2013-08-08T09:04:35.517-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1078305",
    "ThreadId": "443824",
    "Html": "The message is pretty self explanatory:<br />\n<ul>\n<li>Cell Summary!B12 references cell FinancialDataValues!M8</li>\n<li>Cell FinancialDataValues!M8 references cell FinancialData!V7</li>\n<li>Cell FinancialData!V7 references cell ForecastsData!C7</li>\n<li>\nCell ForecastsData!C7 references cell FinancialDataValues!M8 <br />\n</li>\n</ul>\nDoes using<br />\n<div style=\"color:Black;background-color:White;\"><pre>\r\nPHPExcel_Calculation::getInstance()-&gt;cyclicFormulaCount = 1;\r\n</pre></div>work? or haven't you tried it?<br />\n",
    "PostedDate": "2013-08-08T09:18:43.013-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1078331",
    "ThreadId": "443824",
    "Html": "Hello Mark,<br />\nI had even tried to put :<br />\nPHPExcel_Calculation::getInstance()-&gt;cyclicFormulaCount = 400; <br />\n<br />\nwithout any luck... isn't working...<br />\n<br />\nand isn't cyclic...tried it in excel and isn't cyclic at all...phpexcel interprets it like being cycle....<br />\n<br />\ncause in the index array i have some formulas.... in those formulas another formulas... most of them finishing with a IF or with a empty space result... and instead going to my position from index it calculates each one ...<br />\n<br />\nbtw: I have a fix for your index cause isn't working like it should(in excel) -&gt;<br />\n<pre><code>                       if($columnNum==0 &amp;&amp; $rowNum&gt;0 &amp;&amp; count($rowKeys)==1)\n            {\n                $columnNum=$rowNum;\n                $rowNum=$rowKeys[0];\n                $columnKey=$columnKeys[$columnNum-1];\n                $columnKey=key($arrayValues[$rowNum]);\n                return $arrayValues[$rowNum][$columnKey];\n            }</code></pre>\n\nat line 622 in LookupRef.php from the Calculation folder... <br />\n<br />\nthe column case for index was ok, the column and row was ok, except the row one which can be fixed with this...<br />\n<br />\nregarding my main problem... I'm open to suggestion :)<br />\n",
    "PostedDate": "2013-08-08T10:27:58.92-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1078411",
    "ThreadId": "443824",
    "Html": "PHPExcel !== MS Excel\r<br />\n<br />\nWhen I started writing the current PHPExcel calculation engine, it was a learning experience, so I took a relatively simplistic approach using a tried and tested (and easy to understand) approach. It was a significant improvement on the previous version (which used PHP's eval function) severely limiting its functionality (^ was treated as a bitwise operation rather than a power, or a space simply as whitespace), prone to a good many errors, and making it almost impossible to debug.\r<br />\n<br />\nThe PHPExcel calculation engine uses a <a href=\"http://en.wikipedia.org/wiki/LALR_parser\" rel=\"nofollow\">LALR Parser</a> written in PHP to lex and evaluate formulae. This means that in an expression like <code>=INDEX(FinancialDataValues!A8:AS8,B10+Variables!A5)</code>, it evaluates each of the arguments for the function before evaluating the function itself. It means that it evaluates each cell in the range <code>FinancialDataValues!A8:AS8</code> before it evaluates the INDEX() function which (in this case) gives a cyclic reference as shown in the exception trace. Because there is a cyclic reference within that range, the cyclic exception is thrown when cyclicFormulaCount is &lt;= 0;\r<br />\n<br />\nMS Excel itself uses a more complex lexer and evaluator that permits it to take a more intelligent approach to evaluating particular expressions and (more specifically) functions which allows it to evaluate the arguments only as needed. As an example <br />\n<pre><code>    =IF(A1&gt;10, MOD(A1, 10), A1)</code></pre>\n\nPHPExcel will evaluate the results of <code>A1&gt;10</code>, <code>MOD(A1,10)</code> and <code>A1</code>, then pass all three results to the IF function, which tests <code>A1&gt;10</code> and returns the appropriate pre-evaluated result. MS Excel's complexity allows it to <code>know</code> to evaluate <code>A1&gt;10</code> first, and then only evaluate either <code>MOD(A1, 10)</code> or <code>A1</code> depending on the result of <code>A1&gt;10</code>.\r<br />\n<br />\nSo while PHPExcel tries to emulate the functionality of MS Excel as much as possible, the use of a LALR parser does have limitations. I'm currently working on a major rewrite of the calc engine, but it will still be LALR-based (just cleaner, faster code) unless I can find a predictive algorithm that I can get my head round.\r<br />\n<br />\n<br />\nSetting <br />\n<div style=\"color:Black;background-color:White;\"><pre>\r\nPHPExcel_Calculation::getInstance()-&gt;cyclicFormulaCount =1;\r\n</pre></div>before any formula evaluation should prompt the calc engine to handle a cyclic situation and return a result rather than throw an exception. Using a value &gt; 1 will actively change the cyclic values each iteration, while using a value = 1 won't change any cyclic results, but simply use them in the formula.\r<br />\n<br />\nHowever, prior to PHPExcel 1.7.9, the calculation engine was implemented as a singleton, which caused problems for people working with multiple workbooks. In version 1.7.9, I refactored the calculation engine so that there was one global calculation engine (usable when evaluating Excel formulae without instantiating or loading a workbook), and each workbook also had its own calculation engine; so when changing setting (such as the cyclicFormulaCount) you need to identify which instance you want it to apply to.<br />\n<div style=\"color:Black;background-color:White;\"><pre>\r\nPHPExcel_Calculation::getInstance(\n    $objPHPExcel-&gt;getID()\n)-&gt;cyclicFormulaCount =1;\r\n</pre></div>where $objPHPExcel is your workbook instance\r<br />\n<br />\nP.S.\r<br />\n<br />\nI'll look at your fix to INDEX().... despite my protestations that 1.7.9 will be the last of the 1.x branch, I'll probably be releasing a 1.8.0 version.<br />\n",
    "PostedDate": "2013-08-08T12:50:20.78-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1078991",
    "ThreadId": "443824",
    "Html": "Maybe you can still help me with something...\r<br />\n<br />\njust to stop the parser calculating all my range values for the index function I decided to rewrite it....but got stuck at the parameters... I need their value calculated but not the range itself.... just the 2 and optionally 3rd one for the INDEX function\r<br />\n<br />\nIn Calculation.php -&gt; _calculateFormulaValue<br />\n<pre><code>// the bypass for index cyclic formula\n        if(strpos($formula,'INDEX(')!==false)\n        {\n            preg_match_all(&quot;/(INDEX\\()[^\\)]+(?=\\))\\)/&quot;, $formula, $matches);\n            for($v=0;$v&lt;sizeof($matches[0]);$v++)\n            {\n                $curForm=$matches[0][$v];               \n                $with='';               \n                $nrParam=substr_count($curForm, ',')+1;\n                \n                preg_match_all(&quot;/INDEX\\((.+?),/&quot;, $curForm, $par1);\n                $param1=str_replace(&quot;INDEX(&quot;,&quot;&quot;,str_replace(&quot;,&quot;,&quot;&quot;,$par1[0][0]));               \n                \n                if(strpos($param1, &quot;{&quot;))\n                    break;\n                $worksheet='';$range='';\n                \n                if(strpos($param1, &quot;!&quot;)){\n                    $worksheet_=preg_split(&quot;/[!]/&quot;, $param1);\n                    $worksheet=$worksheet_[0];\n                    $range=preg_split(&quot;/[:]/&quot;, $worksheet_[1]);\n                }\n                else{\n                    $range=preg_split(&quot;/[:]/&quot;, $param1);\n                }\n                \n                $s_row=preg_replace(&quot;/[^0-9]/&quot;,&quot;&quot;,$range[0]);\n                $f_row=preg_replace(&quot;/[^0-9]/&quot;,&quot;&quot;,$range[1]);\n                $s_col=preg_replace(&quot;/[^a-zA-Z]/&quot;,&quot;&quot;,$range[0]);\n                $f_col=preg_replace(&quot;/[^a-zA-Z]/&quot;,&quot;&quot;,$range[1]);\n                \n                $s_collString=PHPExcel_Cell::columnIndexFromString($s_col);\n                $f_collString=PHPExcel_Cell::columnIndexFromString($f_col);\n                \n                $valuesArray=array();\n                $c=$r=0;\n                for($posC=$s_collString-1;$posC&lt;$f_collString;$posC++)\n                {\n                    $r=0;\n                    $arrayValue='';\n                    if($s_row==$f_row)\n                    {\n                        $valuesArray[$c][0]=PHPExcel_Cell::stringFromColumnIndex($posC).$f_row;\n                    }\n                    else{                       \n                        for($posR=$s_row;$posR&lt;=$f_row;$posR++)\n                        {                           \n                            $valuesArray[$c][$r]=PHPExcel_Cell::stringFromColumnIndex($posC).$posR;\n                            $r++;\n                        }\n                    }\n                    $c++;\n                }\n                                    \n                if($nrParam==2)\n                {\n                    $param2_=preg_split(&quot;/[,]/&quot;, $curForm);\n                    $param2=rtrim($param2_[1],')');\n                    \n                    if(!is_numeric($param2))\n                    {                       \n                        //$param2=$this-&gt;_calculateFormulaValue($param2);\n//////=&gt; here need to calculate 2nd\n                    }\n                    \n                    echo ($param2-1).&quot;\\r\\n&quot;;\n                    if($s_row==$f_row)\n                        $with= $valuesArray[$param2][0];\n                    else {\n                        $with=$valuesArray[0][$param2];\n                    }                               \n                }\n                else if($nrParam==3)\n                {\n                    $param2_=preg_split(&quot;/[,]/&quot;, $curForm);                 \n                    $param2=$param2_[1]-1;\n                    $param3=rtrim($param2_[2],')')-1;\n//////=&gt; here need to calculate 2nd and 3rd param\n    \n                    $with= $valuesArray[$param3][$param2];                                  \n                }\n                if($worksheet!='')\n                {\n                    $with=$worksheet.'!'.$with;\n                }\n                //$formula=preg_replace('/'.$curForm.'/', $with, $formula);\n                $formula= str_replace($curForm, $with, $formula);\n                //echo $curForm;echo &quot;\\r\\n&quot;;\n                //echo $with; echo &quot;\\r\\n&quot;;\n                //print_r($valuesArray);\n                echo $formula;echo &quot;\\r\\n&quot;;\n            }       \n        }</code></pre>\n\ncan you give me any hint how to get  those param calculated? thank you<br />\n",
    "PostedDate": "2013-08-10T00:44:03.62-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1080450",
    "ThreadId": "443824",
    "Html": "solve it \r<br />\n<br />\nIn Calculation.php you need to replace the _calculateFormulaValue function with:<br />\n<pre><code>/**\n     * Parse a cell formula and calculate its value\n     *\n     * @param   string          $formula    The formula to parse and calculate\n     * @param   string          $cellID     The ID (e.g. A3) of the cell that we are calculating\n     * @param   PHPExcel_Cell   $pCell      Cell to calculate\n     * @return  mixed\n     * @throws  PHPExcel_Calculation_Exception\n     */\n    public function _calculateFormulaValue($formula, $cellID=null, PHPExcel_Cell $pCell = null) {\n        \n        $cellValue = '';\n        \n        //  Basic validation that this is indeed a formula\n        //  We simply return the cell value if not\n        $formula = trim($formula);\n        \n        // the bypass for index cyclic formula\n        if(strpos($formula,'INDEX(')!==false)\n        {\n            preg_match_all(&quot;/INDEX(\\((?:[^()]++|(?1))+\\))/&quot;, $formula, $matches);\n            for($v=0;$v&lt;sizeof($matches[0]);$v++)\n            {\n                //echo &quot;formula initiala: &quot;.$formula.&quot;\\r\\n&quot;;\n                $curForm=$matches[0][$v];               \n                $with='';               \n                $nrParam=substr_count($curForm, ',')+1;\n                \n                preg_match_all(&quot;/INDEX\\((.+?),/&quot;, $curForm, $par1);\n                $param1=str_replace(&quot;INDEX(&quot;,&quot;&quot;,str_replace(&quot;,&quot;,&quot;&quot;,$par1[0][0]));               \n                \n                //echo &quot;formula curenta: &quot;.$curForm.&quot;\\r\\n&quot;;\n                //echo &quot;param 1: &quot;.$param1.&quot;\\r\\n&quot;;\n                if(strpos($param1, &quot;{&quot;))\n                    break;\n                $worksheet='';$range='';\n                \n                            \n                if(substr_count($param1, &quot;:&quot;)&gt;1)\n                {\n                    preg_match_all(&quot;/([a-zA-Z0-9]+)[!]([A-Z0-9:]+)|([a-zA-Z0-9]+)[:]([A-Z0-9]+)/&quot;, $param1, $lotOfRanges);\n                    $tempForm='';                   \n                    for($v_=0;$v_&lt;sizeof($lotOfRanges[0]);$v_++)\n                    {\n                        $valuesArray=array();   \n                        $parameter=$lotOfRanges[0][$v_];\n                        if(strpos($parameter, &quot;!&quot;)){\n                            $worksheet_=preg_split(&quot;/[!]/&quot;, $parameter);\n                            $worksheet=$worksheet_[0];\n                            $range=preg_split(&quot;/[:]/&quot;, $worksheet_[1]);\n                        }\n                        else{\n                            $range=preg_split(&quot;/[:]/&quot;, $parameter);\n                        }\n                        \n                        $s_row=preg_replace(&quot;/[^0-9]/&quot;,&quot;&quot;,$range[0]);\n                        $f_row=preg_replace(&quot;/[^0-9]/&quot;,&quot;&quot;,$range[1]);\n                        $s_col=preg_replace(&quot;/[^a-zA-Z]/&quot;,&quot;&quot;,$range[0]);\n                        $f_col=preg_replace(&quot;/[^a-zA-Z]/&quot;,&quot;&quot;,$range[1]);\n                        \n                        $s_collString=PHPExcel_Cell::columnIndexFromString($s_col);\n                        $f_collString=PHPExcel_Cell::columnIndexFromString($f_col);\n                        \n                        \n                        $c=$r=0;\n                        for($posC=$s_collString-1;$posC&lt;$f_collString;$posC++)\n                        {\n                            $r=0;\n                            $arrayValue='';\n                            if($s_row==$f_row)\n                            {\n                                $valuesArray[$c][0]=PHPExcel_Cell::stringFromColumnIndex($posC).$f_row;\n                            }\n                            else{                       \n                                for($posR=$s_row;$posR&lt;=$f_row;$posR++)\n                                {                           \n                                    $valuesArray[$c][$r]=PHPExcel_Cell::stringFromColumnIndex($posC).$posR;\n                                    $r++;\n                                }\n                            }\n                            $c++;\n                        }\n                        //print_r($valuesArray);\n                        if($nrParam==2)\n                        {\n                            $param2_=preg_split(&quot;/[,]/&quot;, $curForm);\n                            $param2=rtrim($param2_[1],')');\n                            \n                            if(!is_numeric($param2))\n                            {\n                                $par2=&quot;=&quot;.$param2;\n                                $cellValue = $this-&gt;_processTokenStack($this-&gt;_parseFormula($param2,$pCell), $cellID,$pCell);                       \n                                $param2=$cellValue;\n                                if(is_array($param2)){\n                                    $par2=str_replace(&quot;=&quot;, &quot;&quot;, $par2);\n                                    $rr_row=preg_replace(&quot;/[^0-9]/&quot;,&quot;&quot;,$par2);\n                                    $cc_col=preg_replace(&quot;/[^a-zA-Z]/&quot;,&quot;&quot;,$par2);\n                                    $param2=$param2[$rr_row][$cc_col];\n                                }\n                            }\n        \n                            if($s_row==$f_row)\n                                $tempForm= $valuesArray[$param2-1][0];\n                            else {\n                                $tempForm=$valuesArray[0][$param2-1];\n                            }                               \n                        }\n                        else if($nrParam==3)\n                        {\n                            $param2_=preg_split(&quot;/[,]/&quot;, $curForm);                                     \n                            $param2=$param2_[1];\n                            if(!is_numeric($param2))\n                            {\n                                $par2=&quot;=&quot;.$param2;      \n                                $cellValue = $this-&gt;_processTokenStack($this-&gt;_parseFormula($param2,$pCell), $cellID,$pCell);                       \n                                $param2=$cellValue-1;\n                            }\n                            else\n                            {\n                                $param2=$param2-1;\n                            }\n                            \n                            $param3=rtrim($param2_[2],')'); \n                            if(!is_numeric($param3))\n                            {\n                                $par2=&quot;=&quot;.$param3;      \n                                $cellValue = $this-&gt;_processTokenStack($this-&gt;_parseFormula($param3,$pCell), $cellID,$pCell);                       \n                                $param3=$cellValue-1;\n                            }\n                            else\n                            {\n                                $param3=$param3-1;\n                            }                   \n                            $tempForm= $valuesArray[$param3][$param2];                                  \n                        }\n                                    \n                        if($worksheet!='')\n                        {\n                            $tempForm=$worksheet.'!'.$tempForm;\n                        }\n                        $param1=str_replace($parameter, $tempForm, $param1);\n                    }\n                    $with=$param1;\n                }\n                else \n                {\n                    $valuesArray=array();       \n                    if(strpos($param1, &quot;!&quot;)){\n                        $worksheet_=preg_split(&quot;/[!]/&quot;, $param1);\n                        $worksheet=$worksheet_[0];\n                        $range=preg_split(&quot;/[:]/&quot;, $worksheet_[1]);\n                    }\n                    else{\n                        $range=preg_split(&quot;/[:]/&quot;, $param1);\n                    }\n                    \n                    $s_row=preg_replace(&quot;/[^0-9]/&quot;,&quot;&quot;,$range[0]);\n                    $f_row=preg_replace(&quot;/[^0-9]/&quot;,&quot;&quot;,$range[1]);\n                    $s_col=preg_replace(&quot;/[^a-zA-Z]/&quot;,&quot;&quot;,$range[0]);\n                    $f_col=preg_replace(&quot;/[^a-zA-Z]/&quot;,&quot;&quot;,$range[1]);\n                    \n                    $s_collString=PHPExcel_Cell::columnIndexFromString($s_col);\n                    $f_collString=PHPExcel_Cell::columnIndexFromString($f_col);                 \n                    \n                    $c=$r=0;\n                    for($posC=$s_collString-1;$posC&lt;$f_collString;$posC++)\n                    {\n                        $r=0;\n                        $arrayValue='';\n                        if($s_row==$f_row)\n                        {\n                            $valuesArray[$c][0]=PHPExcel_Cell::stringFromColumnIndex($posC).$f_row;\n                        }\n                        else{                       \n                            for($posR=$s_row;$posR&lt;=$f_row;$posR++)\n                            {                           \n                                $valuesArray[$c][$r]=PHPExcel_Cell::stringFromColumnIndex($posC).$posR;\n                                $r++;\n                            }\n                        }\n                        $c++;\n                    }\n                    //print_r($valuesArray);\n                    if($nrParam==2)\n                    {\n                        $param2_=preg_split(&quot;/[,]/&quot;, $curForm);\n                        $param2=rtrim($param2_[1],')');\n                        \n                        if(!is_numeric($param2))\n                        {\n                            $par2=&quot;=&quot;.$param2;\n                            $cellValue = $this-&gt;_processTokenStack($this-&gt;_parseFormula($param2,$pCell), $cellID,$pCell);                       \n                            $param2=$cellValue;\n                            \n                            if(is_array($param2)){\n                                $par2=str_replace(&quot;=&quot;, &quot;&quot;, $par2);\n                                $rr_row=preg_replace(&quot;/[^0-9]/&quot;,&quot;&quot;,$par2);\n                                $cc_col=preg_replace(&quot;/[^a-zA-Z]/&quot;,&quot;&quot;,$par2);\n                                $param2=$param2[$rr_row][$cc_col];\n                            }\n                        }\n    \n                        if($s_row==$f_row)\n                            $with= $valuesArray[$param2-1][0];\n                        else {                          \n                            $with=$valuesArray[0][$param2-1];\n                        }                               \n                    }\n                    else if($nrParam==3)\n                    {\n                        $param2_=preg_split(&quot;/[,]/&quot;, $curForm);                                     \n                        $param2=$param2_[1];\n                        if(!is_numeric($param2))\n                        {\n                            $par2=&quot;=&quot;.$param2;      \n                            $cellValue = $this-&gt;_processTokenStack($this-&gt;_parseFormula($param2,$pCell), $cellID,$pCell);                       \n                            $param2=$cellValue-1;\n                        }\n                        else\n                        {\n                            $param2=$param2-1;\n                        }\n                        \n                        $param3=rtrim($param2_[2],')'); \n                        if(!is_numeric($param3))\n                        {\n                            $par2=&quot;=&quot;.$param3;      \n                            $cellValue = $this-&gt;_processTokenStack($this-&gt;_parseFormula($param3,$pCell), $cellID,$pCell);                       \n                            $param3=$cellValue-1;\n                        }\n                        else\n                        {\n                            $param3=$param3-1;\n                        }                   \n                        $with= $valuesArray[$param3][$param2];                                  \n                    }\n                                \n                    if($worksheet!='')\n                    {\n                        $with=$worksheet.'!'.$with;\n                    }\n                }   \n                //echo &quot;index: &quot;.$with.&quot;\\r\\n&quot;;\n                $formula= str_replace($curForm, $with, $formula);\n                //echo &quot;formula finalala: &quot;.$formula.&quot;\\r\\n&quot;;                \n            }       \n        }\n        \n        if ($formula{0} != '=') return self::_wrapResult($formula);\n        $formula = ltrim(substr($formula,1));\n        if (!isset($formula{0})) return self::_wrapResult($formula);\n\n        $pCellParent = ($pCell !== NULL) ? $pCell-&gt;getWorksheet() : NULL;\n        $wsTitle = ($pCellParent !== NULL) ? $pCellParent-&gt;getTitle() : &quot;\\x00Wrk&quot;;\n\n        if (($cellID !== NULL) &amp;&amp; ($this-&gt;getValueFromCache($wsTitle, $cellID, $cellValue))) {\n            return $cellValue;\n        }\n\n        if (($wsTitle{0} !== &quot;\\x00&quot;) &amp;&amp; ($this-&gt;_cyclicReferenceStack-&gt;onStack($wsTitle.'!'.$cellID))) {\n            if ($this-&gt;cyclicFormulaCount &lt;= 0) {\n                return $this-&gt;_raiseFormulaError('Cyclic Reference in Formula');\n            } elseif (($this-&gt;_cyclicFormulaCount &gt;= $this-&gt;cyclicFormulaCount) &amp;&amp;\n                      ($this-&gt;_cyclicFormulaCell == $wsTitle.'!'.$cellID)) {\n                return $cellValue;\n            } elseif ($this-&gt;_cyclicFormulaCell == $wsTitle.'!'.$cellID) {\n                ++$this-&gt;_cyclicFormulaCount;\n                if ($this-&gt;_cyclicFormulaCount &gt;= $this-&gt;cyclicFormulaCount) {\n                    return $cellValue;\n                }\n            } elseif ($this-&gt;_cyclicFormulaCell == '') {\n                $this-&gt;_cyclicFormulaCell = $wsTitle.'!'.$cellID;\n                if ($this-&gt;_cyclicFormulaCount &gt;= $this-&gt;cyclicFormulaCount) {\n                    return $cellValue;\n                }\n            }\n        }\n\n        //  Parse the formula onto the token stack and calculate the value\n        $this-&gt;_cyclicReferenceStack-&gt;push($wsTitle.'!'.$cellID);\n        \n        $cellValue = $this-&gt;_processTokenStack($this-&gt;_parseFormula($formula, $pCell), $cellID, $pCell);\n        //echo &quot;formula: &quot;.$formula.&quot; -&gt; cell: &quot;.$pCell.&quot; -&gt; cellid: &quot;.$cellID.&quot; -&gt; cellval: &quot;.$cellValue.&quot;\\r\\n&quot;;\n        $this-&gt;_cyclicReferenceStack-&gt;pop();\n\n        // Save to calculation cache\n        if ($cellID !== NULL) {\n            $this-&gt;saveValueToCache($wsTitle, $cellID, $cellValue);\n        }\n\n        //  Return the calculated value\n        return $cellValue;\n    }   //  function _calculateFormulaValue()</code></pre>\n\n",
    "PostedDate": "2013-08-14T03:37:25.66-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1080451",
    "ThreadId": "443824",
    "Html": "In LookupRef.php(under the Calculation folder) replace INDEX function with:<br />\n<pre><code>/**\n     * INDEX\n     *\n     * Uses an index to choose a value from a reference or array\n     *\n     * Excel Function:\n     *      =INDEX(range_array, row_num, [column_num])\n     *\n     * @param   range_array     A range of cells or an array constant\n     * @param   row_num         The row in array from which to return a value. If row_num is omitted, column_num is required.\n     * @param   column_num      The column in array from which to return a value. If column_num is omitted, row_num is required.\n     * @return  mixed           the value of a specified cell or array of cells\n     */\n    public static function INDEX($arrayValues,$rowNum = 0,$columnNum = 0) {\n        \n        if (($rowNum &lt; 0) || ($columnNum &lt; 0)) {\n            return PHPExcel_Calculation_Functions::VALUE();\n        }\n\n        if (!is_array($arrayValues)) {\n            return PHPExcel_Calculation_Functions::REF();\n        }\n    \n        $rowKeys = array_keys($arrayValues);\n        $columnKeys = @array_keys($arrayValues[$rowKeys[0]]);\n\n        if ($columnNum &gt; count($columnKeys)) {\n            return PHPExcel_Calculation_Functions::VALUE();\n        } elseif ($columnNum == 0) {\n            if ($rowNum == 0) {\n                return $arrayValues;\n            }\n            if($columnNum==0 &amp;&amp; $rowNum&gt;0 &amp;&amp; count($rowKeys)==1)\n            {\n                $columnNum=$rowNum;\n                $rowNum=$rowKeys[0];\n                $columnKey=$columnKeys[$columnNum-1];\n                $columnKey=key($arrayValues[$rowNum]);\n                return $arrayValues[$rowNum][$columnKey];\n            }\n            \n            $rowNum = $rowKeys[--$rowNum];\n            \n            $returnArray = array();\n            foreach($arrayValues as $arrayColumn) {\n                \n                if (is_array($arrayColumn)) {\n                    if (isset($arrayColumn[$rowNum])) {\n                        $returnArray[] = $arrayColumn[$rowNum];\n                    } else {                        \n                        return $arrayValues[$rowNum];\n                    }\n                } else {\n                    return $arrayValues[$rowNum];\n                }\n            }\n            return $returnArray;\n        }\n        $columnNum = $columnKeys[--$columnNum];\n        if ($rowNum &gt; count($rowKeys)) {\n            return PHPExcel_Calculation_Functions::VALUE();\n        } elseif ($rowNum == 0) {\n            return $arrayValues[$columnNum];\n        }\n        $rowNum = $rowKeys[--$rowNum];\n\n        return $arrayValues[$rowNum][$columnNum];\n    }   //  function INDEX()</code></pre>\n\nThose 2 function had a fix for the index cyclic bug(isn't ok to calculate them and after that to get the index when it use a stack to keep all reff addresses) \r<br />\n<br />\nSo if you will have a index who will call another index of different sheet will still be ok...also I took in consideration the case when you will have more than 1 range... \r<br />\n<br />\nI really hope that will work for you cause it worked for me and took me one week to get it fixed.\r<br />\n<br />\nRemember that this fix is working for the last phpexcel version from the git(I prefer to not waste my time with 1.7.9 version)<br />\n",
    "PostedDate": "2013-08-14T03:42:12.497-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]