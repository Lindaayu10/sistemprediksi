{
  "WorkItem": {
    "AffectedComponent": {
      "Name": "All",
      "DisplayName": "All"
    },
    "ClosedComment": "Caching and other improvements have been introduced for this.",
    "ClosedDate": "2010-08-30T04:53:56.48-07:00",
    "CommentCount": 0,
    "Custom": null,
    "Description": "Check http://www.codeplex.com/PHPExcel/Thread/View.aspx?ThreadId=31206 for more info.",
    "LastUpdatedDate": "2013-05-16T05:43:31.437-07:00",
    "PlannedForRelease": "",
    "ReleaseVisibleToPublic": false,
    "Priority": {
      "Name": "Medium",
      "Severity": 100,
      "Id": 2
    },
    "ProjectName": "PHPExcel",
    "ReportedDate": "2008-07-10T23:45:51.19-07:00",
    "Status": {
      "Name": "Closed",
      "Id": 4
    },
    "ReasonClosed": {
      "Name": "Unassigned"
    },
    "Summary": "Improving performance and memory on data dumps",
    "Type": {
      "Name": "Feature",
      "Id": 1
    },
    "VoteCount": 21,
    "Id": 6857
  },
  "FileAttachments": [
    {
      "FileId": 1825,
      "FileName": "test_myphpexcel.php",
      "DownloadUrl": ".\\1825"
    },
    {
      "FileId": 1826,
      "FileName": "test_phpexcel.php",
      "DownloadUrl": ".\\1826"
    },
    {
      "FileId": 2083,
      "FileName": "finaltesting.xlsx",
      "DownloadUrl": ".\\2083"
    },
    {
      "FileId": 2667,
      "FileName": "shared-styles-discussion-1.zip",
      "DownloadUrl": ".\\2667"
    },
    {
      "FileId": 3190,
      "FileName": "wi-6857-hyperlink.patch",
      "DownloadUrl": ".\\3190"
    },
    {
      "FileId": 3432,
      "FileName": "short-variable-names.patch",
      "DownloadUrl": ".\\3432"
    }
  ],
  "Comments": [
    {
      "Message": "Added file.",
      "PostedDate": "2008-07-10T23:46:27.19-07:00",
      "Id": -2147483648
    },
    {
      "Message": "",
      "PostedDate": "2008-07-10T23:46:27.58-07:00",
      "Id": -2147483648
    },
    {
      "Message": "Added file.",
      "PostedDate": "2008-07-10T23:46:35.847-07:00",
      "Id": -2147483648
    },
    {
      "Message": "",
      "PostedDate": "2008-07-10T23:46:36.207-07:00",
      "Id": -2147483648
    },
    {
      "Message": "",
      "PostedDate": "2008-07-11T08:46:47.213-07:00",
      "Id": -2147483648
    },
    {
      "Message": "",
      "PostedDate": "2008-07-11T08:57:39.167-07:00",
      "Id": -2147483648
    },
    {
      "Message": "",
      "PostedDate": "2008-07-11T14:14:17.323-07:00",
      "Id": -2147483648
    },
    {
      "Message": "",
      "PostedDate": "2008-07-13T08:16:37.917-07:00",
      "Id": -2147483648
    },
    {
      "Message": "",
      "PostedDate": "2008-07-14T05:10:21.533-07:00",
      "Id": -2147483648
    },
    {
      "Message": "",
      "PostedDate": "2008-07-17T21:15:45.95-07:00",
      "Id": -2147483648
    },
    {
      "Message": "",
      "PostedDate": "2008-07-21T05:13:05.543-07:00",
      "Id": -2147483648
    },
    {
      "Message": "",
      "PostedDate": "2008-07-28T02:07:27.167-07:00",
      "Id": -2147483648
    },
    {
      "Message": "",
      "PostedDate": "2008-08-29T00:26:02.8-07:00",
      "Id": -2147483648
    },
    {
      "Message": "",
      "PostedDate": "2008-09-04T06:04:25.2-07:00",
      "Id": -2147483648
    },
    {
      "Message": "This is interesting... I noticed like koyama it can take very long to generate a file. Good luck concerning this issue!\r\nFor example, with the finaltesting.xlsx file, it took me about 2min and I set up the server so, otherwise it was not working...\r\nmax_execution_time = 600  \r\nmax_input_time = 600\t\r\nmemory_limit = 512M      ",
      "PostedDate": "2008-09-04T06:08:37.607-07:00",
      "Id": -2147483648
    },
    {
      "Message": "",
      "PostedDate": "2008-09-04T06:08:38.137-07:00",
      "Id": -2147483648
    },
    {
      "Message": "",
      "PostedDate": "2008-09-12T03:19:50.973-07:00",
      "Id": -2147483648
    },
    {
      "Message": "",
      "PostedDate": "2008-09-29T06:41:58.05-07:00",
      "Id": -2147483648
    },
    {
      "Message": "",
      "PostedDate": "2008-11-06T13:36:01.787-08:00",
      "Id": -2147483648
    },
    {
      "Message": "",
      "PostedDate": "2009-01-16T08:07:52.79-08:00",
      "Id": -2147483648
    },
    {
      "Message": "",
      "PostedDate": "2009-01-19T10:25:10.413-08:00",
      "Id": -2147483648
    },
    {
      "Message": "I carefully would like to suggest that we instead focus on trying to reduce memory consumption of the workbook when it is loaded in memory through use of shared styles. This should automatically result in faster data dumps using the writers.\r\n\r\nIn other words, if object representation of the workbook more closely resembles how real Excel workbooks look (which use shared styles) then this will put less strain on writers, and the readers can take advantage of already determined style sharing info. Execution time by readers and writers could drop to nearly zero this way.\r\n\r\nInstead strain can be put on the core, but styling of a worksheet can in most cases be done in just a handful of operations if one operates on many cells at a time, so it is not really a problem, I think.\r\n\r\nIt would be a gigantic step forward if this work item is cracked. It is probably not unrealistic that we can speed things up by approx. 100 times for larger workbooks and even more for huge workbooks. What do you think?",
      "PostedDate": "2009-01-22T05:48:51.393-08:00",
      "Id": -2147483648
    },
    {
      "Message": "This would indeed be one of the possible steps in improving memory issues. In Excel2007, it should be possible to first scan for styling info and then share style X in cells Y and Z and so on.\r\n\r\nOne thing to think about: if someone alters the style info, is he meaning that he's altering the shared style or just the style for one cell?",
      "PostedDate": "2009-01-22T22:52:12.473-08:00",
      "Id": -2147483648
    },
    {
      "Message": ">> One thing to think about: if someone alters the style info, is he meaning that he's altering the shared style or just the style for one cell?\r\n\r\nThis is exactly what needs to be tackled! He should of course not be altering the shared style. That would not be intuitive and it would not be easy to for example load a workbook and change the style for just one cell.\r\n\r\nTherefore I suggest this:\r\n1. Introduce class called PHPExcel_Tools_Style (think of this as the style dialog in MS Office Excel)\r\n\r\n2. Allow something like this:\r\nsheet->setSelectedCells('A1:G25')\r\nPHPExcel_Tools_Style->applyFromArray(<styleArray>)\r\n\r\n3. When you do 2), PHPExcel will automatically take care of rearranging style sharing as necessary under the hood.\r\n\r\n4. In order not to break current interface, change getStyle(<cell>) to this:\r\n\r\nfunction getStyle(<cell>) {\r\n\t$this->setSelectedCell(<cell>);\r\n\treturn PHPExcel_Tools_Style;\r\n}\r\n\r\nSo getStyle() now just sets selected cell to the one cell and passes the handle to the Excel style tool dialog.\r\n\r\nVoila! No interface broken and easy to explain using \"Style tool dialog\"-analogy.\r\n\r\nSo when a user asks: How do I style my workbook in PHPExcel? We answer: Do like you do in MS Office Excel, just select cells and use the style dialog!\r\n\r\nNote: This is not exactly the same as what we have, but judging from what I see users are doing, this would not break their scripts.",
      "PostedDate": "2009-01-22T23:26:19.163-08:00",
      "Id": -2147483648
    },
    {
      "Message": "It might also be worth typing this in with row and column styles.\r\n\r\n\r\nDidn't Brian McKenna come up with something last November to treat diffrent cell styles as a hashed array, with the cell just pointing to the entry for its style.\r\n",
      "PostedDate": "2009-01-23T00:55:19.097-08:00",
      "Id": -2147483648
    },
    {
      "Message": "Anyone volunteering to implement this feature? It's quite huge, but would be a huge improvement too.",
      "PostedDate": "2009-01-23T01:09:15.227-08:00",
      "Id": -2147483648
    },
    {
      "Message": ">> Didn't Brian McKenna come up with something last November to treat diffrent cell styles as a hashed array, with the cell just pointing to the entry for its style.\r\n\r\nYes, some optimizations were carried out, which was good, but this is different, and I believe this should mean huge improvements in speed as well as memory, I'm imagining something like 100 ~1000 times faster and similar reduction in memory usage.\r\n\r\n>> Anyone volunteering to implement this feature? It's quite huge, but would be a huge improvement too.\r\n\r\nIt is huge, but I can start to sit down and analyze this if necessary. Maybe we can break this up in stages where the completion of each stage result in improvements. There are several candidates for shared objects, at least styles, fonts, number formats, but also column dimensions, row dimensions.\r\n\r\nThe success of this will depend on that we teach users to style multiple cells at one time via e.g. duplicateStyleArray() instead of looping through one cell at a time like getStyle(<cell>)->... But again, this will make sense to the user, after all no one styles one cell at a time in Excel, they select mulitple cells and then use the style tool to style them at once.\r\n\r\nThis may take time, but I'll see what I can come up with, and post back.\r\n",
      "PostedDate": "2009-01-23T03:16:26.117-08:00",
      "Id": -2147483648
    },
    {
      "Message": "Sounds great, I think a good discussion prior to development is appropriate here.\r\nStyles are the ideal candidate at first, I think other objects are not used as much as styles.",
      "PostedDate": "2009-01-23T04:02:40.537-08:00",
      "Id": -2147483648
    },
    {
      "Message": "I have a couple of code snippets so we can discuss this in more details. Please download the attachment \"shared-styles-discuss-1.zip\". Nothing of this has been tested, it is just to make sure we are talking about the same thing. I am fully aware that everything needs to be discussed thoroughly and that we must not rush with this. Let's imagine what we can do:\r\n\r\n1. PHPExcel.php (look in attachment, only showing differences)\r\n\r\nWe are now talking about shared styles, that is for the whole workbook, so let's move the style collection from the individual worksheets to the workbook.\r\n\r\nContrary to the \"style collection\" on worksheet level which we have now, these global workbook styles are now indexed by integer, _styles[0], _styles[1], ... etc. instead of _styles['A1'] etc.\r\n\r\nWe will need some methods to add a style, get the style collection, and get a style by index (the mentioned keys 0,1,2,...)\r\n\r\nAlso, notice the constructor which creates an instance of the new \"MS Office Excel toolbar\". Really, the toolbar belongs to the application and not the workbook, but we don't have an application object in our classes, so let's just give each workbook it's own toolbar.\r\n\r\n2. PHPExcel_Cell.php\r\n\r\nThe new thing here is that each cell has an associated style index. For example, getStyleIndex() gives you the numeric index to the style in our workbook style collection (PHPExcel_Style[]).\r\n\r\n3. PHPExcel_Worksheet.php\r\n\r\nWe introduce method for selecting a range of cells, setSelectedRange('A1:D4'). Actually, this is not just an imaginary method, but very real, in MS Office Excel one can select a cell range too. There is also something called \"selected cell\" in Excel, there can only be one \"selected cell\" per worksheet (pane, actually), and we already have this concept in PHPExcel_Worksheet today.\r\n\r\nNot sure about the details here, but so far, we can decide that setSelectedRange('A1:D4') at the same time sets the \"selected cell\" to be the upper left cell in the range.\r\n\r\nNotice also, how we modify our existing method getStyle(). It returns a different class of object, but in a way so interface is not broken. More about this later.\r\n\r\nAlso, duplicateStyleArray() is modified. Under the hood it will operate on shared styles in a way so these classes will work much faster. More about this later.\r\n\r\n4. PHPExcel_Tools.php\r\n\r\nThis is the new class corresponding to the MS Office Excel Toolbar. There is room for methods here for getting other components of the toolbar. Right now we introduce just getStyle() which returns the \"MS Office Excel style dialog\", because that is what we are focusing on now.\r\n\r\n5. PHPExcel_Tools_Style.php\r\n\r\nThis is the \"MS Office Excel style dialog\", this is again divided into components such as \"alignment options\", \"border options\", etc. There are methods, getAligment(), getBorders() etc. which return those components of the style dialog, PHPExcel_Tools_Style_Alignment etc. These methods are named exactly like the methods for PHPExcel_Style, in fact, this is what ensures that we don't break current interface.\r\n\r\n6. PHPExcel_Tools_Style_Alignment.php\r\n\r\nThis is the alignment section in the \"MS Office Excel style dialog\".\r\nhttp://img110.imageshack.us/img110/8148/alignmentzm0.png\r\n\r\nAgain, in order not to break interface, this class will implement the exact same methods from PHPExcel_Style_Alignment.\r\n\r\nSo how do we do that? Let's take getHorizontal(). Usually, this returns a class constant for whatever PHPExcel_Style_Alignment we are operating on. But now we have a toolbar PHPExcel_Tools_Style_Alignment rather than a real style, so instead we return what we see in the toolbar. Therefore, getHorizontal() will look up what is the active sheet and active cell, then fetch the cell's associated (shared) style and look up getHorizontal() there.\r\n\r\nThis is exactly how the toolbar works in MS Office Excel. However, there is one this to consider, what if the cell does not exist in the cell collection? Well, the answer here is that the toolbar will show the default style. (We need to discuss this, I think they are not working 100% correctly in PHPExcel at the moment)\r\n\r\nSo now, what about applyFromArray($styleArray) for this class? What this should do is to look up 1) what is the active sheet? 2) what is the selected cell range? 3) update styles and cell style indexes so we get what we would get in MS Office Excel when we invoke the tool on a selected cell range in a sheet.\r\n\r\nThis is the complicated part, because we must remember we are now operating on shared styles. If we just alter the shared style, we may be altering the style for cells outside the selected range and sheet, which we don't want. But it may not be so complicated after all. What we do is to fetch the shared styles (PHPExcel_Style) for all the selected cells. Then we clone them and applyFromArray($styleArray) on the clones. Finally we update the style indexes for the selected cells so they point to the cloned, altered styles instead.\r\n\r\n7. Why is this faster?\r\n\r\nBecuase now one PHPExcel_Style corresponds exactly to one style record in MS Office Excel. That means the readers and writers will need no brain. The reader delivers the workbook as is. Thus it will only occupy memory comparable to the filesize of workbook. \r\n\r\nThe writer can also write the workbook as is. This is not entirely true because we need to think of some garbage collection of styles. I have not discussed this, but maybe we can keep track of styles by associating the count of references from cells. Then only write styles with at least one reference.\r\n\r\nFinally, duplicateStyleArray() is going to be fast because it now benefits from shared styles.\r\n\r\n8. Column and row styles?\r\n\r\nI suggest that we wait with this for a moment in order not to complicate things. They are different animals and are in the family with column and row dimensions. Still, I beleive they will fit perfectly into the above framework if we later introduce e.g $worksheet->setSelectedColumns(A:D) and $worksheet->setSelectedRows(123:529). \r\n\r\n",
      "PostedDate": "2009-01-24T09:56:38.84-08:00",
      "Id": -2147483648
    },
    {
      "Message": "",
      "PostedDate": "2009-01-24T09:56:40.56-08:00",
      "Id": -2147483648
    },
    {
      "Message": "Erik, this concepts looks good! I like the idea of PHPExcel_Tools_x, but I'm not sure if we really need it. It is some sort of supervisor on top of styles, and I guess that the PHPExcel_Style itself can take care of this too.\r\n\r\nHowever, for clearness, I do think the PHPExcel_Tools_x is the way to go. This should integrate quite well in the current API, though we'll need some modifications to readers and writers.\r\n\r\nHow about I create a branch in SVN for this?",
      "PostedDate": "2009-01-28T22:46:51.79-08:00",
      "Id": -2147483648
    },
    {
      "Message": "Sounds great! Will try to hook up on whatever concept you suggest. Will also try to get better understanding of how Excel 2007 works vs Excel 5. I am really looking forward to this!",
      "PostedDate": "2009-01-29T01:21:18.47-08:00",
      "Id": -2147483648
    },
    {
      "Message": "Erik, I've created a branch for this in SVN (/PHPExcel/branches/wi6857-memory)\r\n\r\nIf you want to, you can use this branch to try out a proof of concept.",
      "PostedDate": "2009-02-03T23:50:32.453-08:00",
      "Id": -2147483648
    },
    {
      "Message": "Thank you, I will try out some of the ideas together with perhaps Excel5 reader/writer to get an indication of how much memory/execution time can be saved. Not sure how to get rid of PHPExcel_Tools_Style, but I will think!",
      "PostedDate": "2009-02-04T20:20:04.39-08:00",
      "Id": -2147483648
    },
    {
      "Message": "",
      "PostedDate": "2009-03-10T11:02:53.023-07:00",
      "Id": -2147483648
    },
    {
      "Message": "",
      "PostedDate": "2009-04-16T04:34:47.837-07:00",
      "Id": -2147483648
    },
    {
      "Message": "The tests are going fine and are almost ready to be incorporated in the source code. Changes did not make it for PHPExcel 1.6.7. Will post a message later explaining the details. In short, memory problems will become much rarer, but to get the full performance gain we should start using duplicateStyleArray() to style many cells at once instead of treating single cells/ single style properties at once.",
      "PostedDate": "2009-04-22T05:30:25.997-07:00",
      "Id": -2147483648
    },
    {
      "Message": "Updating source code merging from branch wi6857-memory.\r\n\r\n0. Simple test. Plain read/write xlsx -> xlsx of a sample workbook with medium use of styles, 13 sheets, approx 250 cells in each sheet.\r\n----\r\nBefore (1.6.7):\r\n- Read took: 88 seconds\r\n- Write took: 42 seconds\r\n- Peak memory usage: 72.75 MB\r\n\r\nNow (source code)\r\n----\r\n- Read took: 6 seconds\r\n- Write took: 3 seconds\r\n- Peak memory usage: 18.75 MB \r\n\r\n\r\n1. Fast way to style cells is now like this:\r\n----\r\n$objWorksheet->duplicateStyleArray($styleArray, 'A1:P555');\r\n\r\nNo matter how many cells in the range, and how many properties there are in the style array, execution time of this line of code is practically speaking the same.\r\n\r\n\r\n2. Avoid styling cells one at a time using loops, setting one property at a time. This works slower now than before because there is some performance cost for keeping memory usage down at a lower level.\r\n----\r\nAVOID TOO MUCH OF THIS KIND! :\r\n\r\nfor ($col = 0; $col <= 27; $col++) {\r\n\tfor ($row = 1; $row <= 555; $row++) {\r\n\t\t$objWorksheet->getStyleByColumnAndRow($col, $row)->getFont()->setName('Arial');\r\n\t\t$objWorksheet->getStyleByColumnAndRow($col, $row)->getFont()->setBold(true);\r\n\t\t$objWorksheet->getStyleByColumnAndRow($col, $row)->getFill()->getEndColor()->setARGB('FF00FF00');\r\n\t\t$objWorksheet->getStyleByColumnAndRow($col, $row)->getFill()->getStartColor()->setARGB('FF0000FF');\r\n\t\t$objWorksheet->getStyleByColumnAndRow($col, $row)->getFill()->setFillType(PHPExcel_Style_Fill::FILL_PATTERN_DARKGRAY);\r\n\t}\r\n}\r\n\r\nThe previous technique in 1) is faster by a factor:\r\n\r\n(number of cells) x (number of style properties)\r\n\r\nThis can be a quite large factor if there are many cells and many properties being styled!\r\n\r\n",
      "PostedDate": "2009-04-27T18:08:02.947-07:00",
      "Id": -2147483648
    },
    {
      "Message": "Erik, this is great! Should we be adding a note on this in the documentation?",
      "PostedDate": "2009-04-27T23:43:43.37-07:00",
      "Id": -2147483648
    },
    {
      "Message": "",
      "PostedDate": "2009-04-27T23:43:44.87-07:00",
      "Id": -2147483648
    },
    {
      "Message": "Yes, indeed. Affected sections in the PHPExcel Developer Documentation are \"Formatting a Cell\" and \"Setting the default style of a worksheet\". Will try to prepare something at the end of this week!",
      "PostedDate": "2009-04-28T05:35:17.44-07:00",
      "Id": -2147483648
    },
    {
      "Message": "Ok, some more ideas!\r\n\r\nFirst, the PHPExcel_Cell object seems to require around 1 KB of memory per piece, that is even for empty cells. This is quite expensive and is about 10-100 times the amount of memory a cell occupies in the Excel file. Treatment of large Excel files (> 100,000 cells) even without styles may still be difficult with PHPExcel (memory exhaust ~ 1GB).\r\n\r\nSmall possible improvements:\r\n\r\n- Reduce number of private variables for PHPExcel_Cell, $_hyperlink and $_dataValidation are candidates. They are occupying space even when not in use. Perhaps they can be moved to the PHPExcel_Worksheet, as $_hyperlinks['A1'] etc.? This alone can save around 10% of memory. (Tried by commenting them out).\r\n\r\nBig improvements (completely eliminate memory usage by cells) like this:\r\n\r\n- Introduce a cell supervisor (similar to the style supervisor).\r\n- Introduce (optional) MySQL database cache for storing cells.\r\n\r\nIt could work like this:\r\n\r\n/** PHPExcel_Worksheet */\r\nfunction getCell('A1') {\r\n\t$this->_parent->setActiveSheetIndex($this->_parent->getIndex($this));\r\n\t$this->setActiveCell('A1');\r\n\treturn PHPExcel->getCellSupervisor();\r\n}\r\n\r\n/** PHPExcel_Cell */\r\nfunction getValue() {\r\n\tif ($this->_isSupervisor) {\r\n\t\t$sheet = $this->getParent();\r\n\t\t$coordinate = $sheet->getActiveCell(); // e.g. 'A1'\r\n\t\t\r\n\t\tif ($useMySQLcaching) {\r\n\t\t\t$sql = \"select `value` from `cell` where `sheetTitle` = '$sheet->getTitle()' and `coordinate` = '$coordinate'\";\r\n\t\t\t...\r\n\t\t\treturn $value;\r\n\t\t}\r\n\t\telse {\r\n\t\t\t$cellCollection = $this->getParent()->getCellCollection();\r\n\t\t\t$cell = $cellCollection[$coordinate];\r\n\t\t\treturn $cell->getValue();\r\n\t\t}\r\n\t} else {\r\n\t\treturn $this->_value;\r\n\t}\r\n}\r\n\r\nAdditional benefits:\r\n- Gets rid of most recursive object references between PHPExcel_Cell and PHPExcel_Worksheet\r\n- A cell supervisor prevents spawning unnecessary cell object when using getCell('A1').\r\n\r\nDo you think something of this can be used?\r\n",
      "PostedDate": "2009-05-06T19:06:03.19-07:00",
      "Id": -2147483648
    },
    {
      "Message": "Some thoughts...\r\n\r\n- Reduce number of private variables for PHPExcel_Cell, $_hyperlink and $_dataValidation are candidates. They are occupying space even when not in use. Perhaps they can be moved to the PHPExcel_Worksheet, as $_hyperlinks['A1'] etc.? This alone can save around 10% of memory. (Tried by commenting them out).\r\nAgree with this! This is a good option to put in the worksheet.\r\n\r\nAs for the big improvements: \r\n- Cell supervisor sounds OK, althoug I'm a little bit affraid this will cause performance issues when doing exhaustive calculations that require lot of read access?\r\n\r\n- About caching: we could introduce a \"ICellCacheProvider\" interface and some basic implementations, like DiskCellCacheProvider, MemCachedCellCacheProvider, ... This means we are not relying on MySQL or any other storage engine available, and allowing a very pluggable system for storing cached cells.",
      "PostedDate": "2009-05-06T23:40:57.393-07:00",
      "Id": -2147483648
    },
    {
      "Message": ">> About caching: we could introduce a \"ICellCacheProvider\"\r\nI like that idea! In that case the cell cache provider has to be a cell cache for the whole cell collection. Maybe one cell cache per worksheet?\r\n\r\nAll I an sure of right now is that we need to get rid of the PHPExcel_Cell object for huge scale files, except for the cell single cell supervisor. Currently for a 1 million cell workbook, we have 1 million PHPExcel_Cell objects. No matter how small we get the PHPExcel_Cell any overhead of just some 100 bytes will exhaust memory.\r\n\r\nIf you look at the PEAR::Spreadsheet_Excel_Writer it doesn't store 1 cell as 1 variable. Rather it concatenates data on the fly as you use the write() method. That is one of the reasons it performs better than PHPExcel, but this approach is also very dangerous as the class has no control with the order the cell data is written in.\r\n\r\nAs I see it the ICellCacheProvider would somehow have to respond to methods such as insertRow(), insertColumn(), mergeCells() etc. Am I correct, here? These operations seem to translate just fine into database queries, at least\r\n\r\n>> Cell supervisor sounds OK, althoug I'm a little bit affraid this will cause performance issues when doing\r\n>> exhaustive calculations that require lot of read access?\r\nI wouldn't worry too much about this, I think we're talking just a few clock cycles here. The cell supervisor is not really doing any work. Just sitting there as a link between the \"user\" and the ICellCacheProvider. I would think of the cell supervisor as the \"formula bar\" component in the MS Office Excel application.\r\n",
      "PostedDate": "2009-05-07T06:47:20.27-07:00",
      "Id": -2147483648
    },
    {
      "Message": "Ok with the cell supervisor. It should be using an ICellCacheProvider interface.\r\nAs a default ICellCacheProvider, I'd say we create a DefaultCellCacheProvider, using memory.\r\nOther than that, we can create a DiskCellCacheProvider, DBCellCacheProvider, ...\r\n\r\nICellCacheProvider should be worksheet specific at least, but I'm still in doubt to make it workbook specific... \r\n",
      "PostedDate": "2009-05-08T02:05:52.683-07:00",
      "Id": -2147483648
    },
    {
      "Message": ">> I'd say we create a DefaultCellCacheProvider, using memory.\r\nAgreed, it would be obvious to try to transform our current solution to an ICellCacheProvider first.\r\n\r\n>> Other than that, we can create a DiskCellCacheProvider, DBCellCacheProvider, ...\r\nNot sure what data structure the DiskCellCacheProvider will be based on, but if possible, ok.\r\n\r\n>> ICellCacheProvider should be worksheet specific at least, but I'm still in doubt to make it\r\n>> workbook specific... \r\nPHPExcel is not really geared for handling multiple workbooks at once. Although there is definitely a need for this (discussions tell us so). I think you're right that this is something we should address at some point.\r\n",
      "PostedDate": "2009-05-08T02:48:36.963-07:00",
      "Id": -2147483648
    },
    {
      "Message": "I'll take care of the disk cache version once we have the interface defined...",
      "PostedDate": "2009-05-08T03:45:09.007-07:00",
      "Id": -2147483648
    },
    {
      "Message": "I did some further optimizations for the applyFromArray() styling methods. As a kind of side effect it is now possible to do like this (notice the cell range):\r\n\r\n$objWorksheet->getStyle('A1:F43')->applyFromArray($styleArray);\r\n\r\nwhich is exactly the same as this:\r\n\r\n$objWorksheet->duplicateStyleArray($styleArray, 'A1:F43');\r\n\r\nHow about if we deprecate duplicateStyleArray() in favor of getStyle() like shown?\r\n\r\n",
      "PostedDate": "2009-05-16T21:44:27.21-07:00",
      "Id": -2147483648
    },
    {
      "Message": "If we take this approach, duplicateStyleArray() can indeed be deprecated. I think the proposed solution is more easy to read so definitely go this road.",
      "PostedDate": "2009-05-18T02:13:45.557-07:00",
      "Id": -2147483648
    },
    {
      "Message": "This is great! That means I can do a couple of adjustments and write some text about this for the \"PHPExcel Developer Documentation\". Will also check if some of the examples in the Tests folder can make use of this.",
      "PostedDate": "2009-05-18T03:11:01.94-07:00",
      "Id": -2147483648
    },
    {
      "Message": "I have updated the library deprecating duplicateStyleArray() in favor of getStyle([cellrange])->applyFromArray(). Also updated some of the tests + documentation.\r\n\r\nHow about removing 23sharedstyles.php from the tests? The method has been obsoleted by the automatic sharing of styles.",
      "PostedDate": "2009-06-18T20:08:13.707-07:00",
      "Id": -2147483648
    },
    {
      "Message": "Ok, test can be removed.",
      "PostedDate": "2009-06-19T04:41:23.123-07:00",
      "Id": -2147483648
    },
    {
      "Message": "",
      "PostedDate": "2009-06-22T11:00:50.653-07:00",
      "Id": -2147483648
    },
    {
      "Message": "Maarten, can you take a quick glance at patch wi-6857-hyperlink.patch, and see if this is something I can commit? For a start, it eliminates the private hyperlink property of the cell object and moves it to the worksheet - like we discussed.\r\n\r\nUsing the patch, I tried to read a workbook with approx 100.000 cells. Memory usage dropped from 117MB to 106MB. Execution time also dropped from 20 sec to 18 sec.",
      "PostedDate": "2009-07-12T20:05:39.377-07:00",
      "Id": -2147483648
    },
    {
      "Message": "",
      "PostedDate": "2009-07-12T20:05:42.097-07:00",
      "Id": -2147483648
    },
    {
      "Message": "",
      "PostedDate": "2009-07-14T03:19:37.487-07:00",
      "Id": -2147483648
    },
    {
      "Message": "Erik, hyperlink patch can be committed.",
      "PostedDate": "2009-08-02T22:52:53.95-07:00",
      "Id": -2147483648
    },
    {
      "Message": "Ok, I have applied the hyperlink patch. Will now see if same technique can be applied to dataValidation property to lower the PHP memory usage a bit more.",
      "PostedDate": "2009-08-03T13:41:35.583-07:00",
      "Id": -2147483648
    },
    {
      "Message": "Similar patch created and applied in SVN for the dataValidation property.\r\nAgain, I tried to read a workbook with approx 100.000 cells. Memory usage drops from 106MB to 98MB.",
      "PostedDate": "2009-08-03T16:00:12.33-07:00",
      "Id": -2147483648
    },
    {
      "Message": "",
      "PostedDate": "2009-08-10T00:11:31.313-07:00",
      "Id": -2147483648
    },
    {
      "Message": "About the cache provider... How do you see the cell supervisor?\r\n\r\nI was thinking the ICellCacheProvider interface could look like an ArrayObject: this would enable us to plug in the interface instead of the current array in every worksheet, making integration of the caching mechanism easier?",
      "PostedDate": "2009-09-30T23:11:16.14-07:00",
      "Id": -2147483648
    },
    {
      "Message": "Maybe we are thinking the same. I'm not sure. It's still a bit abstract. If you have some code snippets I will perhaps begin to see the picture?",
      "PostedDate": "2009-10-01T00:01:53.503-07:00",
      "Id": -2147483648
    },
    {
      "Message": "One big question: will we cache Cell objects, or only value/formula?",
      "PostedDate": "2009-10-01T00:47:36.137-07:00",
      "Id": -2147483648
    },
    {
      "Message": "I was thinking that we cache all the private properties of the cell.\r\nCurrently, they are these:\r\n\r\nprivate $_value;\r\nprivate $_calculatedValue = null;\r\nprivate $_dataType;\r\nprivate $_xfIndex; // index to cell style\r\n\r\nRelated to this, there are some thoughts about rearrangement of the cell properties:\r\n\r\nhttp://phpexcel.codeplex.com/WorkItem/View.aspx?WorkItemId=10607\r\nhttp://phpexcel.codeplex.com/Thread/View.aspx?ThreadId=69213\r\n\r\nWhat do you think?",
      "PostedDate": "2009-10-01T04:05:13.713-07:00",
      "Id": -2147483648
    },
    {
      "Message": "Not directly related to caching, and what should or shouldn't be cached, but a more general comment on memory usage for the cell instances.\r\n\r\nCurrently, all our exceptions are with hard-coded values within the methods themselves, e.g\r\n\r\npublic function hasHyperlink() {\r\n\tif (!isset($this->_parent)) {\r\n\t\tthrow new Exception('Cannot check for hyperlink when cell is not bound to a worksheet');\r\n\t}\r\n\r\n\treturn $this->_parent->hyperlinkExists($this->getCoordinate());\r\n}\r\n\r\nIs the Zend engine smart enough to only have one copy of the actual exception message text that is applied to all instances, or could using class constants for message texts reduce memory overhead?\r\n\r\nconst HYPERLINK_NOT_BOUND_ERROR\t\t= 'Cannot check for hyperlink when cell is not bound to a worksheet';\r\n\r\npublic function hasHyperlink() {\r\n\tif (!isset($this->_parent)) {\r\n\t\tthrow new Exception(self::HYPERLINK_NOT_BOUND_ERROR);\r\n\t}\r\n\r\n\treturn $this->_parent->hyperlinkExists($this->getCoordinate());\r\n}\r\n\r\nor even a separate static class for texts\r\n\r\npublic function hasHyperlink() {\r\n\tif (!isset($this->_parent)) {\r\n\t\tthrow new Exception(PHPExcel_Cell_Errors::HYPERLINK_NOT_BOUND_ERROR);\r\n\t}\r\n\r\n\treturn $this->_parent->hyperlinkExists($this->getCoordinate());\r\n}\r\n\r\nI've not actually tried this to see if it make a difference in memory usage when you have a large number of instances of an object, so I might set up an experiment to see what effects the different variations actually have on memory usage.\r\n",
      "PostedDate": "2009-10-01T04:39:29.86-07:00",
      "Id": -2147483648
    },
    {
      "Message": "My thoughts on what we should cache: I agree with Erik that it should be the private attributes rather than the object. \r\n\r\nCaching the object increases the volumes of data being cached, so alternatives to database and disk (such as APC or memcache) become less attractive. It's practical to hold large numbers of cell attributes in APC or memcache, because you're caching the absolute minimum of data; but objects would quickly use up any available external cache.\r\n",
      "PostedDate": "2009-10-01T04:49:46.083-07:00",
      "Id": -2147483648
    },
    {
      "Message": "Agree on only storing the required properties to limit cache footprint as well. How will be plugging this into the main library?",
      "PostedDate": "2009-10-01T05:07:54.09-07:00",
      "Id": -2147483648
    },
    {
      "Message": "I think the supervisor could work like this:\r\n$cell = $sheet->getCell('A1'); // returns the global cell supervisor instead of individual cell object\r\n\r\njust sets the selected cell to 'A1' in the sheet, nothing else. And returns the global cell supervisor.\r\n\r\nOnly when you call, e.g.\r\n$cell->getValue();\r\n\r\nthen the cell cache is consulted. I.e. there is some logic:\r\n\r\nfunction getValue() {\r\n  $activeCell = look up what the active cell coordinate for sheet, e.g. 'A1'\r\n  switch($whichCache) {\r\n    case 'database': look up in database the value for 'A1', $value = result of some DB query\r\n    case 'memory': look in e.g. $value = $cellcollection['sheetX']['A1']->getValue(); // like usually\r\n    case 'disk': look up in some file, perhaps some CSV-like file?\r\n  }\r\n  return $value;\r\n}\r\n\r\nSame for other functions, e.g\r\n\r\nfunction getHighestColumn() {\r\n  switch($whichCache) {\r\n    case 'database': $value = select max(col)...\r\n    case 'memory': ...\r\n    case 'disk': ...\r\n  }\r\n  return $value;\r\n}\r\n\r\nSince this is a bit ugly, we could instead wrap it in some neat interface, also so one can plug in a custom cache.\r\n\r\nLater we could optimize allowing bulk insert/retrieval of cells, because it may not be so fast to insert 1,000,000 cells using 1,000,000 queries either to database, disk, or whatever.",
      "PostedDate": "2009-10-01T05:54:07.757-07:00",
      "Id": -2147483648
    },
    {
      "Message": "Think it would be best to first implement the cell value changes?\r\n\r\nProposal for the caching interface:\r\n\r\ninterface ICellCacheProvider {\r\n  public function getCellValues($coordinates); // returns array with cell values\r\n  public function setCellValues($coordinates, $values); // array with values passed in\r\n}\r\n\r\nDefault implementation would be to use memory.",
      "PostedDate": "2009-10-01T09:29:24.413-07:00",
      "Id": -2147483648
    },
    {
      "Message": ">> Think it would be best to first implement the cell value changes?\r\nAgreed.\r\n\r\n>> Proposal for the caching interface\r\nLooks promising! How about methods insertNewRowBefore(), removeRow(), insertNewColumnBefore(), removeColumn(), would they also be included in interface ICellCacheProvider ?",
      "PostedDate": "2009-10-01T10:23:06.5-07:00",
      "Id": -2147483648
    },
    {
      "Message": "That's something that can stay at the ReferenceHelper, no?",
      "PostedDate": "2009-10-01T12:36:21.817-07:00",
      "Id": -2147483648
    },
    {
      "Message": ">> That's something that can stay at the ReferenceHelper, no?\r\n\r\nImagine we have a sheet with 100,000 rows and insert 1 row at the top. All cells need their coordinate updated. In principle one can do this with setCellValues() for the entire set of cells, but this doesn't allow the cell cache provider to take advantage of possible shortcuts.\r\n\r\nWith a database cache, inserting one row at the top could be done smart like\r\nsql = \"update `sheet` set `row` = `row` + 1\"\r\n\r\nwhich undoubtedly beats using setCellValues() in execution time.",
      "PostedDate": "2009-10-01T13:31:00.973-07:00",
      "Id": -2147483648
    },
    {
      "Message": "Guess it would be a combined effort: ReferenceHelper is stil lrequired to update formula references and stuff. Good point though.",
      "PostedDate": "2009-10-01T22:58:31.86-07:00",
      "Id": -2147483648
    },
    {
      "Message": "Shortening the variable names of the private properties in PHPExcel/Cell.php reduces memory usage when I test with XAMPP/Windows XP. Memory usage reading a workbook with 100,000 cells goes from 104.25 MB to 100.00 MB.\r\n\r\nIs this a PHP-tip anyone has heard of? Is it worth including in the source code? See patch: short-variable-names.patch",
      "PostedDate": "2009-10-13T14:47:33.427-07:00",
      "Id": -2147483648
    },
    {
      "Message": "",
      "PostedDate": "2009-10-13T14:47:36.687-07:00",
      "Id": -2147483648
    },
    {
      "Message": "That is bizarre! Is this something known as performance tip in the PHP community?",
      "PostedDate": "2009-10-13T22:48:09.81-07:00",
      "Id": -2147483648
    },
    {
      "Message": ">> That is bizarre! Is this something known as performance tip in the PHP community?\r\nI've generated a couple of tests and posted them on a number of the PHP development boards (devshed, sitepoint, PHP developers network and PHPFreaks). It's being met with a mix of surprise and downright disbelief; but nobody seemed to be aware of it at all.\r\n\r\nMy tests also noted that execution time might be fractionally faster as well, though that could simply be fewer calls to malloc",
      "PostedDate": "2009-10-14T05:27:13.71-07:00",
      "Id": -2147483648
    },
    {
      "Message": "Yeah, I thought it was strange, I was assuming that PHP was smart enough out of the box to shorten variable names in memory. Does one really need a PHP accelerator for this. Looking forward what comes out of your postings, Mark.",
      "PostedDate": "2009-10-14T05:58:58.247-07:00",
      "Id": -2147483648
    },
    {
      "Message": ">> Yeah, I thought it was strange, I was assuming that PHP was smart enough out of the box to shorten variable names in memory. \r\nSo was I, but it looks not... and I'm beginning to understand why.\r\nThe bytecode PHP still needs to know the actual variable/attribute and function/method names for use in error handling and serialize() (among others). I was assuming that for OOP, it would handle this slightly differently, and maintain a \"class definition\" with all the long name details, and each instance would just contain pointers to this name map; so that each instance would use a minimal amount of memory, and functions such as serialize would cross reference the data and pointers from the instance with the class name map to generate their output.\r\nHowever, that could only work if all attributes were predefined in the class definition.... but PHP's loose coding rules allow you to define new attributes dynamically within your methods.... against a specific instance of the class, so these couldn't exist in a \"class map\" in advance. Therefore, PHP takes the quick and dirty approach of holding the names within each instance.\r\n\r\n>> Does one really need a PHP accelerator for this. Looking forward what comes out of your postings, Mark.\r\nI'm not sure that a PHP accelerator would work any differently, but it may be an area for further investigation. Likewise, generating fully-compiled code may also be worth investigating... see if these give any memory benefits.\r\nWhile we'd want to maintain a source download that would run \"as is\", we might be able to provide an \"accelerated\" downoad and/or compiled downloads (for different platforms) if either method reduced the memory footprint.\r\n\r\n\r\nOn PHPFreaks, somebody else raised the point that public properties use a smaller memory footprint than protected properties, which in turn are lower than private properties.... which I've also verified.\r\nOptimum performance solution: all attributes should be public, and have meaningless names like $a, $b, $c, etc.... scores NUL POINTS (eurovision song contest reference) on the useability scale though.",
      "PostedDate": "2009-10-14T09:40:49.023-07:00",
      "Id": -2147483648
    },
    {
      "Message": "Did you get a response from the PHP team on this?",
      "PostedDate": "2009-10-14T22:56:30.59-07:00",
      "Id": -2147483648
    },
    {
      "Message": "Switching this discussion to e-mail because this issue page is getting excessively long",
      "PostedDate": "2009-10-15T01:09:02.33-07:00",
      "Id": -2147483648
    },
    {
      "Message": "According to my calculations we should be able to cut down memory usage to one half, from around 1KB to around 500 bytes overhead per cell just by introducing the cell supervisor. That is without any cell caching mechanism. The primary reason for the memory reduction is that the cell supervisor would make the following private properties in PHPExcel_Cell redundant: $_parent, $_row, $column.\r\n\r\nOnce a cell supervisor is in place I think it will be easier to implement the cell cache mechanism. The cell supervisor may not require more than 100 to 200 lines of code so I can try to put together something for the cell supervisor and see what happens.",
      "PostedDate": "2009-11-03T20:42:00.573-08:00",
      "Id": -2147483648
    },
    {
      "Message": "",
      "PostedDate": "2010-08-30T04:53:56.48-07:00",
      "Id": -2147483648
    },
    {
      "Message": "",
      "PostedDate": "2013-02-21T19:05:09.9-08:00",
      "Id": -2147483648
    },
    {
      "Message": "",
      "PostedDate": "2013-05-16T05:43:31.437-07:00",
      "Id": -2147483648
    }
  ]
}